<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 74976cdb263ef841c5fc2c3f91ca7e284adce552 Maintainer: nilgun Status: ready -->
<!-- CREDITS: tpug, sezer -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>İşlevler</title>

  <sect1 xml:id="functions.user-defined">
   <title>Kullanıcı tanımlı işlevler</title>
   <para>
    Bir işlev, şöyle bir söz dizimi kullanılarak tanımlanabilir:
   </para>
   <para>
    <example>
     <title>- İşlev kullanımını gösteren sözde kod</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Örnek işlev.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Bir işlevin içerisinde geçerli her tür PHP kodu kullanılabilir, buna
    başka işlevler ve <link linkend="language.oop5.basic.class">sınıf</link>
    tanımları da dahildir.
   </simpara>
   <para>
    İşlev isimleri, PHP'deki diğer isimlerle aynı kurallara tabidir. Geçerli
    bir işlev ismi bir harf ya da alt çizgi ile başlar, herhangi bir sayıda
    geçerli harf, sayı ya da alt çizgi ile devam eder. Düzenli ifade olarak,
    şu şekilde ifade edebiliriz:
   <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
   </para>
   <simpara>
    İşlevlerin çağrılmadan önce tanımlanmaları, aşağıdaki iki örnekte
    görüldüğü gibi koşullu olarak tanımlandıkları durumlar haricinde
    gerekmez.
   </simpara>
   <para>
    Bir işlev aşağıdaki iki örnekte gösterildiği gibi koşullu olarak
    tanımlandıysa, bu işlev tanımının işlev çağrılmadan
    <emphasis>önce</emphasis> yapılması gerekmektedir.
   </para>
   <para>
    <example>
     <title>- Koşula bağlı işlevler</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Henüz varolmadığı için foo() buradan çağrılamaz,
   ancak bar() çağrılabilir */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Uygulamanın çalışması bana erişene kadar ben yokum.\n";
  }
}

/* $makefoo doğru olduğundan
   artık foo() çağrılabilir */

if ($makefoo) foo();

function bar()
{
  echo "Program başlatıldığı anda ben de varolurum.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>- İşlev içinde işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "foo() çağrılana kadar yokum.\n";
  }
}

/* Henüz varolmadığı için
   bar() çağrılamaz. */

foo();

/* Artık bar() çağrılabilir,
   foo() çağrıldığında bar()
   erişilebilir hale gelir */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP'de tüm işlevler ve sınıflar betik genelinde geçerlidir - bir işlevin
    içinden tanımlanmış olsalar bile işlevin dışından çağrılabilirler.
   </para>
   <simpara>
    PHP işlevlerin farklı bağımsız değişkenli yeni tanımlarının yapılmasını
    desteklemediği gibi, işlevler yeniden tanımlanamaz veya tanımsız
    kılınamaz.
   </simpara>
   <note>
    <simpara>
      İşlev isimleri <literal>A</literal>'dan <literal>Z</literal>'ye kadar
      ASCII karakterler için büyük-küçük harf duyarsızdır, ancak işlev
      isimlerini tanımlandıkları halleriyle kullanmak daha iyidir.
    </simpara>
   </note>
   <simpara>
    <link linkend="functions.variable-arg-list">Bağımsız değişken sayısı değişken
    işlevler</link> desteklendiği gibi işlevlerde <link
    linkend="functions.arguments.default">öntanımlı bağımsız değişken</link>
    kullanımı da desteklenmektedir. Daha ayrıntılı bilgi edinmek için
    <function>func_num_args</function>, <function>func_get_arg</function> ve
    <function>func_get_args</function> işlevlerine de bakınız.
   </simpara>

   <para>
    PHP'de işlevlerin kendilerini çağırması da mümkündür.
    <example>
     <title>- Kendini çağıran işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
    <note>
     <simpara>
      Kendini çağıran işlev ve yöntemler bunu 100-200 kere yaparsa yığıt
      taşabilir ve çalışan betiğin durdurulmasına sebep olabilir. Özellikle,
      kendini çağırma sayısı sonsuza giderse bu bir programlama hatası
      sayılır.
     </simpara>
    </note>
   </para>

  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>İşlev bağımsız değişkenleri</title>

   <simpara>
    Bir işleve veri, virgül ayraçlı ifadelerden oluşan bir bağımsız değişken listesi
    ile aktarılır. İşlev çalıştırılmadan önce bağımsız değişkenler soldan sağa doğru
    değerlendirilir (<emphasis>hevesli</emphasis> değerlendirme).
   </simpara>
   <para>
    PHP, bağımsız değişkenlerin değerleriyle aktarılmalarını (öntanımlı), <link
    linkend="functions.arguments.by-reference">gönderimli aktarım</link>ı ve
    <link linkend="functions.arguments.default">öntanımlı bağımsız değişken
    kullanımı</link>nı destekler.
    <link linkend="functions.variable-arg-list">Bağımsız değişken sayısı değişken
    işlevler</link> ve <link linkend="functions.named-arguments">İsimli
    bağımsız değişkenler</link> de desteklenmektedir.
   </para>
   <para>
    <example>
     <title>- İşlevlere dizi aktarımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function dizi_kabul_eder($girdi)
{
    echo "$girdi[0] + $girdi[1] = ", $girdi[0]+$girdi[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP 8.0.0'dan itibaren, işlev bağımsız değişkenlerinin sonunda göz ardı edilecek
    bir virgül bulunabilir. Bu, özellikle bağımsız değişken listesinin uzun olduğu
    veya uzun isimler içerdiği durumlarda, bağımsız değişkenleri alt alta sıralamayı
    kolaylaştırır.
   </para>
   <para>
   <example>
    <title>- Virgül ile sonlanan işlev bağımsız değişkenleri örneği</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // 8.0.0 öncesinde bu virgüle izin verilmezdi.
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Gönderimli bağımsız değişken kullanımı</title>

    <simpara>
      Öntanımlı olarak, işlev bağımsız değişkenleri değerleriyle aktarılırlar (bu
      durumda bir bağımsız değişkenin değeri işlev içinde değiştirildiğinde işlevin
      çağrıldığı yerdeki değeri bundan etkilenmez. İşlevin çağrıldığı yerdeki
      değerinin de değişmesini istiyorsanız gönderimli bağımsız değişken
      kullanmalısınız.
    </simpara>
    <para>
      Bir işleve bir bağımsız değişkenin daima gönderimli olarak aktarılmasını
      istiyorsanız, işlev bildiriminde o bağımsız değişkenin başına &amp;
      karakterini koyarak bunu sağlayabilirsiniz:
    </para>
    <para>
     <example>
      <title>- Gönderimli işlev bağımsız değişkenlerinin aktarımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function şunu_da_ekle(&$dizge)
{
    $dizge .= 've bir kaç karakter eklenmiştir.';
}
$dzg = 'Bu bir dizgedir ';
şunu_da_ekle($dzg);
echo $dzg;    // 'Bu bir dizgedir ve bir kaç karakter eklenmiştir.'
              //  çıktısını verir.
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Gönderimli aktarılması beklenen bir değeri değişkeniyle değil değeriyle
     aktarmak bir hatadır.
    </para>
   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Öntanımlı bağımsız değişken değerleri</title>

    <para>
      Bir işlevde, bağımsız değişkenler için öntanımlı değerler, değişken ataması
      biçiminde tanımlanabilir. Öntanımlı değer sadece işlev çağrısı
      sırasında bağımsız değişken belirtilmemişse kullanılır. Şuna özellikle
      dikkat edilmelidir: &null; değer öntanımlı değer olarak tanımlanamaz.
    </para>
    <para>
     <example>
      <title>- İşlev içinde öntanımlı bağımsız değişken kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangisi = "orta şekerli")
{
    return "Bir fincan $hangisi kahve yapalım.\n";
}
echo kahveyap();
echo makecoffee(null);
echo kahveyap("az şekerli");
?>
]]>
      </programlisting>
      &example.outputs;
     <screen>
<![CDATA[
Bir fincan orta şekerli kahve yapalım.
Bir fincan kahve yapalım.
Bir fincan az şekerli kahve yapalım.
]]>
      </screen>
     </example>
    </para>
    <para>
     Öntanımlı değer olarak, diziler, özel &null; türü ve PHP 8.1.0 itibariyle
     <link linkend="language.oop5.basic.new">new SınıfAdı()</link> sözdizimi ile
     nesneler kullanılabilir.
    </para>
    <para>
     <example>
      <title>- Sayıl olmayan türlerin öntanımlı değer olarak kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangi = array("orta şekerli"), $neyde = NULL)
{
    $neyde = is_null($neyde) ? "ocakta" : $neyde;
    return "Bir fincan ".join(" bir fincan ", $hangi)." kahve $neyde yapıldı.\n";
}
echo kahveyap();
echo kahveyap(array("çok şekerli", "az şekerli"), "mangalda");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Bir fincan orta şekerli kahve ocakta yapıldı.
Bir fincan çok şekerli bir fincan az şekerli kahve mangalda yapıldı.
]]>
      </screen>
     </example>
    </para>
    <para>
     <example>
      <title>- Öntanımlı değer olarak nesne kullanımı (PHP 8.1.0 ve sonrası)</title>
      <programlisting role="php">
<![CDATA[
<?php
class ÖntanımlıDemleyici {
    public function demle() {
        return 'Çay demleniyor.\n';
    }
}
class PorselenDemleyici {
    public function demle() {
        return 'Özel çayınız demleniyor.\n';
    }
}
function çayyap($demleyici = new ÖntanımlıDemleyici)
{
    return $demleyici->demle();
}
echo çayyap();
echo çayyap(new PorselenDemleyici);
?>
]]>
      </programlisting>

      &example.outputs;
      <screen>
<![CDATA[
Çay demleniyor.
Özel çayınız demleniyor.
]]>
      </screen>
     </example>
    </para>

    <simpara>
     Öntanımlı değer bir değişken, bir sınıf üyesi ya da bir işlev çağrısı
     değil, bir sabit ifadesi olmalıdır.
    </simpara>
    <para>
     Öntanımlı bağımsız değişkenleri kullanırken, öntanımlama yapılmış tüm
     bağımsız değişkenlerin öntanımlama yapılmamış tüm bağımsız değişkenlerden sonra yer
     alması gerektiğine dikkat edin. Aksi takdirde çağrı sırasında bunlar
     atlanamaz. Aşağıdaki örneği inceleyin:
    </para>
    <para>
     <example>
      <title>- Öntanımlı bağımsız değişkenlerin hatalı kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($miktar = "az", $katkı)
{
    return "Bir kase $miktar $katkı içeren yoğurt yapılıyor.\n";
}

echo yoğurtyap("çilek");   // "çilek" $miktar olarak işleme alınır ve
                           // tek bağımsız değişken aktarımı hataya yol açar.
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Fatal error: Uncaught ArgumentCountError: Too few arguments to function yoğurtyap(), 1 passed in dnm.php on line 7 and exactly 2 expected in dnm.php:2
Stack trace:
#0 dnm.php(7): yoğurtyap('\xC3\xA7ilekli')
#1 {main}
  thrown in dnm.php on line 2
]]>
      </screen>
     </example>
    </para>
    <para>
      Şimdi, yukarıdakini bununla karşılaştıralım:
    </para>
    <para>
     <example>
      <title>- Öntanımlı bağımsız değişkenlerin doğru kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($katkı, $miktar = "az")
{
    return "Bir kase $miktar $katkı içeren yoğurt yapılıyor.\n";
}

echo yoğurtyap("çilek");   // "çilek" $katkı olarak işleme alınır
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Bir kase az çilek içeren yoğurt yapılıyor.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP 8.0.0 ve sonrasında, çok sayıda seçimlik bağımsız değişkeni atlamak için
     <link linkend="functions.named-arguments">isimli bağımsız değişkenler</link>
     kullanılabilir.
    </para>
    <para>
     <example>
      <title>- Öntanımlı işlev bağımsız değişkenlerinin doğru kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($katkı = "şeker", $miktar = "az", $tarz = "doğal")
{
    return "Bir kase $miktar $katkı içeren $tarz yoğurt yapılıyor.\n";
}
echo makeyogurt($tarz: "süzme");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Bir kase az çilek içeren süzme yoğurt yapılıyor.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP 8.0.0 ve sonrasında, işlev çağrısında zorunlu bağımsız değişkenlerin
     seçimliklerden sonra tanımlanması <emphasis>kullanımdan
     kaldırılmıştır</emphasis>. Bu genellikle, kullanılmayacak olan öntanımlı
     değer atlanarak çözümlenir. Bunun tek istisnası, türü örtük olarak &null;
     yapan <code>Tür $param = null</code> biçimindeki bağımsız değişkenlerdir. Bunun
     kullanımına hala izin verilmekteyse de bunun yerine,
     <link linkend="language.types.declarations.nullable">&null; olabilen
     tür</link> kullanımı önerilmektedir.
     <example>
      <title>- Seçimliklerin zorunlu bağımsız değişkenlerden sonra bildirimi</title>
      <programlisting role="php">
<![CDATA[
 <?php
 function foo($a = [], $b) {} // Öntanımlı bağımsız değişken böyle kullanılamaz;
                              // PHP 8.0.0 ve sonrasında kullanımda değil

 function foo($a, $b) {}      // İşlevsel olarak aynı, bir uyarı verilmez
 function bar(A $a = null, $b) {} // Hala izin veriliyor; $a null olabiliyor
 function bar(?A $a, $b) {}       // Önerilen kullanım
 ?>
 ]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      PHP 7.1.0 ve sonrasında, öntanımlı değer belirtilmemiş bir bağımsız değişkenin
      atlanması <classname>ArgumentCountError</classname> yavrulanmasına yol
      açmaktadır; önceki sürümlerde sadece bir uyarı çıktılanırdı.
     </simpara>
    </note>

    <note>
     <simpara>
      Gönderimli aktarılabilen bağımsız değişkenler öntanımlı değer içerebilir.
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Değişken uzunlukta bağımsız değişken listesi</title>

    <simpara>
     PHP, kullanıcı tanımlı işlevlerde bağımsız değişken listesinin sonuna
     <literal>...</literal> konarak listenin uzatılmasını destekler.
    </simpara>

    <para>
     Bağımsız değişken listeleri, işlevin değişken sayıda bağımsız değişken kabul ettiğini
     belirtmek için <literal> ... </literal> simgesini içerebilir. Bu durumda
     bağımsız değişkenler değişkene bir dizi olarak aktarılır:
    </para>

    <para>
     <example>
     <title>- Değişken uzunlukta bağımsız değişkenler için <literal>...</literal> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
10
]]>
     </screen>
    </example>
   </para>

   <para>
    Bir diziyi, bir <classname>Traversable</classname> değişkeni veya bir
    sabiti bağımsız değişken listesi haline getirmek için işlev çağrılırken de
    <literal>...</literal> kullanılabilir. Örnek:
   </para>
   <para>
    <example>
     <title> -Bağımsız değişkenlere erişmek için <literal>...</literal>
        kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3
3
]]>
     </screen>
    </example>
   </para>

   <para>
    <literal>...</literal> dizgeciğinden önce normal konumsal bağımsız değişkenler
    belirtilebilir. Bu durumda <literal>...</literal> ile üretilen diziye
    sadece konumsal bağımsız değişkenlerle eşleşen sonuncu bağımsız değişkeni izleyen
    eşleşmeyen bağımsız değişkenler eklenir.
   </para>

   <para>
    <literal>...</literal> dizgeciğinin önüne <link
    linkend="language.types.declarations">tür bildirimi</link> de
    eklenebilir. Bu durumda <literal>...</literal> kapsamındaki tüm
    bağımsız değişkenlerin bu tür bildirimi ile eşleşmesi gerekir.
    <example>
     <title>Değişken bağımsız değişkenlerde tür bildirimi</title>
     <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' gün';

// Bir DateInterval nesnesi olmadığından bu başarısız olur.
echo total_intervals('d', null);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3 gün
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
     </screen>
    </example>
   </para>

   <para>
    Son olarak, <literal>...</literal> dizgeciğinin önüne bir
    <literal>&amp;</literal> ekleyerek değişken bağımsız değişkenleri
    <link linkend="functions.arguments.by-reference">gönderimli</link>
    olarak da aktarabilirsiniz.
   </para>

  </sect2>

  <sect2 xml:id="functions.named-arguments">
   <title>İsimli bağımsız değişkenler</title>

   <para>
    PHP 8.0.0, var olan konumsal bağımsız değişkenlerin bir uzantısı olarak isimli
    bağımsız değişkenleri tanıttı. İsimli bağımsız değişkenler, bağımsız değişkenlerin konuma
    göre değil bağımsız değişken adına göre işleve iletilmesine izin verir. Bu,
    bağımsız değişkeni kendini belgelendiren bağımsız değişken haline, bağımsız değişkenleri de
    sıralamadan bağımsız hale getirir ve öntanımlı değerlerin keyfi olarak
    atlanmasına izin verir.
   </para>

   <para>
    İsimli bağımsız değişkenler, değerin önüne iki nokta üst üste ile bağımsız değişken
    adı eklenerek iletilir. Ayrılmış anahtar sözcüklerin bağımsız değişken adları
    olarak kullanılmasına izin verilir. Bağımsız değişken adı bir tanımlayıcı
    olmalıdır, bir değişkenle belirtilmesine izin verilmez.
   </para>
   <para>
    <example>
     <title>- İsimli bağımsız değişken sözdizimi</title>
     <programlisting role="php">
<![CDATA[
<?php
işlevim(değişkenAdı: $değer);
array_foobar(array: $değer);

// desteklenmiyor
işlev_adı($değişkeneSaklanmışBağımsızDeğişkenAdı: $$değer);
?>
]]>
      </programlisting>
     </example>
     <example>
      <title>- Konumsal ve isimli bağımsız değişkenler</title>
      <programlisting role="php">
<![CDATA[
<?php
// Konumsal bağımsız değişkenler:
array_fill(0, 100, 50);

// İsimli bağımsız değişkenler:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    İsimli bağımsız değişkenlerin aktarılma sırasının bir önemi yoktur.
   </para>
   <para>
    <example>
     <title>- Farklı bağımsız değişken sırasıyla yukarıdaki örnek</title>
     <programlisting role="php">
<![CDATA[
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    İsimli bağımsız değişkenler konumsal bağımsız değişkenlerle birleştirilebilir. Bu
    durumda, isimli bağımsız değişkenler konumsal bağımsız değişkenlerden sonra gelmelidir.
    Sıralarına bakılmaksızın, bir işlevin isteğe bağlı bağımsız değişkenlerinden
    yalnızca bazılarını belirtmek de mümkündür.
   </para>
   <para>
    <example>
     <title>- İsimli bağımsız değişkenlerle konumsal bağımsız değişkenleri birleştirmek
     </title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Same as
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Aynı bağımsız değişkeni birden fazla kullanmak bir <classname>Error</classname>
    istisnasına yol açar.
   </para>
   <example>
    <title>- Aynı bağımsız değişkenin birden fazla kullanımında
     <classname>Error</classname> yavrulanması
    </title>
    <programlisting role="php">
     <![CDATA[
<?php
function foo($param) { ... }
foo(param: 1, param: 2);
// Hata: $param isimli bağımsız değişkeni önceki bağımsız değişkeni geçersiz kılıyor
foo(1, param: 2);
// Hata: $param isimli bağımsız değişkeni önceki bağımsız değişkeni geçersiz kılıyor
?>
]]>
    </programlisting>
   </example>
   <para>
    PHP 8.1.0 itibariyle, bağımsız değişken genişletmesinden sonra isimli bağımsız değişken
    kullanımına izin verilmektedir ancak, isimli bağımsız değişkenin genişletmedeki
    bağımsız değişkeni geçersiz kılmaması <emphasis>gerekir</emphasis>.
   </para>

   <example>
    <title>- Genişletme sonrası isimli bağımsız değişken kullanımı</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a, $b, $c = 3, $d = 4) {
  return $a + $b + $c + $d;
}
var_dump(foo(...[1, 2], d: 40)); // 46
var_dump(foo(...['b' => 2, 'a' => 1], d: 40)); // 46
var_dump(foo(...[1, 2], b: 20)); // Ölümcül hata. İsimli bağımsız değişken $b, genişletmedekini geçersiz kılıyor
?>
]]>
     </programlisting>
    </example>

   </sect2>
  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Dönen değerler</title>

   <para>
    Değerler, isteğe bağlı return deyimi kullanılarak döndürülür. Diziler ve
    nesneler dahil herhangi bir tür döndürülebilir. Bu, işlevin çalıştırmayı
    hemen bitirmesine ve denetimi çağrıldığı satıra geri aktarmasına neden
    olur. Daha fazla bilgi için <function>return</function> işlevine bakın.
   </para>

   <note>
    <para>
     <function>return</function> kullanılmazsa &null; değeri döndürülür.
    </para>
   </note>

   <para>
    <example>
     <title>- <function>return</function> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // çıktısı: '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Bir işlev çok sayıda değer döndürebildiği gibi bir dizi döndürerek de
    aynı sonuç sağlanabilir.
   </para>
   <para>
    <example>
      <title>- Çok sayıda değeri bir diziyle döndürmek</title>
      <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return (0, 1, 2);
}

// Burada dizi üyeleri tek tek toplanmaktadır
[$zero, $one, $two] = small_numbers();

// 7.1.0 öncesinde, bu sadece list() oluşumu ile sağlanabilirdi
list($zero, $one, $two) = small_numbers();

?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Bir işlevden gönderim döndürmek için hem işlev bildiriminde hem de dönen
     değer bir değişkene atandığında gönderim işleci &amp; kullanılır:
    </para>

    <para>
     <example>
      <title>- Bir işlevden gönderim döndürmek</title>
      <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}
?>

$newref =& returns_reference();
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Gönderimler hakkında daha fazla bilgi için <link
     linkend="language.references">Gönderimlerle İlgili Herşey</link>
     bölümüne bakınız.
    </simpara>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Değişken işlevler</title>

   <para>
    PHP değişken işlev kavramını desteklemektedir. Yani, bir değişken isminin
    sonuna parantez eklenmişse, PHP aynı isimde bir işlev olup olmadığına
    bakar ve bulduğu takdirde bu işlevi çalıştırmaya çalışır. Başka olası
    işlemlerin yanında, bu özellik geri çağırımların, işlev tablolarının ve
    benzerlerinin gerçeklenmesinde kullanılabilir.
   </para>
   <para>
    Değişken işlevler,
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> ve benzeri dil yapılarında çalışmayacaktır.
    Bu yapıları değişken işlev olarak kullanmak istediğiniz takdirde, gerekli
    sarmalayıcı işlevleri kendiniz yazmalısınız.
   </para>
   <para>
    <example>
     <title>- Değişken işlev örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Bu echo için sarmalayıcı işlevdir
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // foo() çağrılır

$func = 'bar';
$func('test');  // bar() çağrılır

$func = 'echoit';
$func('test');  // echoit() çağrılır
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Değişken işlev özelliğini kullanarak bir nesnenin bir yöntemini de
    çağırabilmeniz mümkündür.
    <example>
     <title>- Değişken yöntem örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bu Bar() yöntemini çağıracaktır
    }

    function Bar()
    {
        echo "Bu bir Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Bu $foo->Variable() işlevini çağıracaktır

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Static türünden yöntemleri çağırırken işlev çağrısı 'static property'
    işlecinden daha güçlüdür:
    <example>
     <title>Statik özellikli yöntem çağrısı örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Bu 'static property' basar. Bu bağlamda $variable gerekmez.
$variable = "Variable";
Foo::$variable();  // Bu bağlamda $variable değişkenini okuyan $foo->Variable() çağrılır.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Karmaşık çağrılar</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";;
$func(); // "bar" basar
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>is_callable</function></member>
      <member><function>call_user_func</function></member>
      <member><function>function_exists</function></member>
      <member><link linkend="language.variables.variable">değişken
        değişkenler </link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Yerleşik işlevler</title>

   <para>
    PHP standart olarak birçok işlev ve oluşum ile birlikte gelmektedir.
    Bunun yanında, özel PHP eklentilerinin derlenmesini gerektiren, aksi
    takdirde "tanımsız işlev" hatası üreten işlevler de mevcuttur. Örneğin,
    <function>imagecreatetruecolor</function> gibi <link linkend="ref.image"
    >görüntü</link> işlevlerini kullanabilmek için, PHP'yi
    <productname>GD</productname> desteğiyle derlemiş olmanız gerekir. Ya da,
    <function>mysqli_connect</function> işlevini kullanabilmek için, PHP'nin
    <link linkend="book.mysqli">MySQLi</link> desteği ile derlenmiş olması
    gerekmektedir. Bunların yanında, bütün PHP sürümlerine eklenen <link
    linkend="ref.strings">dizge</link> ve <link linkend="ref.var"
    >değişken</link> işlevleri gibi birçok çekirdek işlev de mevcuttur.
    <function>phpinfo</function> ya da
    <function>get_loaded_extensions</function> işlevlerine yapılacak bir
    çağrı ile PHP'ye hangi eklentilerin yüklenmiş olduğunu görebilirsiniz.
    Birçok uzantı öntanımlı olarak etkinleştirilmiş olup PHP Kılavuzunda bu
    eklentilerle ilgili geniş bilgi verilmiştir. PHP'yi nasıl yapılandırmanız
    gerektiğiyle ilgili bilgiyi <link linkend="configuration"
    >yapılandırma</link> ve <link linkend="install">kurulum</link> bölümleri
    ile eklerdeki özel bölümlerde bulabilirsiniz.
   </para>
   <para>
    Kılavuzun <link linkend="about.prototypes">işlev tanımı nasıl
    okunur</link> bölümünde bir işlev tanımının nasıl okunup anlaşılabileceği
    ile ilgili bilgiler bulunmaktadır. Bir işlevin bir değer mi döndürdüğü
    yoksa aktarılan değerlerle sadece işlem mi yaptığını anlamak önemlidir.
    Örneğin, <function>str_replace</function> değiştirilmiş dizgeyle
    dönerken, <function>usort</function> sadece kendisine aktarılan değer
    üzerinde çalışır. Ayrıca, her kılavuz sayfasında her işlevin
    bağımsız değişkenleri, davranış değişiklikleri, başarı ya da başarısızlık
    durumunda döndürülen değerler ve kullanılabilirlik bilgileri
    bulunmaktadır. Bu önemli (ve sıklıkla algılanması güç) farklılıkların
    bilinmesi, doğru PHP kodunun yazılabilmesi için büyük önem taşımaktadır.
   </para>
   <note>
    <simpara>
     Bir işleve, işlevin kabul etmeyeceği bir bağımsız değişken (örneğin, bir dizge
     gerekirken bir dizi) belirtilmesi durumunda işlevin döndüreceği değer
     tanımsızdır (beklenen değer olmayabilir). Böyle bir durumda çoğunlukla
     &null; döner, fakat bu böyle düzenlenmiş demek değildir ve buna
     güvenilmemelidir. PHP 8.0.0 itibariyle, böyle bir durumda bir
     <classname>TypeError</classname> istisnası yavrulanması gerekir.
    </simpara>
   </note>
   <note>
    <para>
     Sayıl türler, zorlanmış kipteyken yerleşik işlevlerde öntanımlı olarak
     &null; olabilmektedir. PHP 8.1.0'dan itibaren nullable türünde
     bildirilmeyen bir dahili işlev bağımsız değişkenine &null; aktarılması
     önerilmemekte ve sayıl türlerin açıkça nullable olarak bildirilmesini
     gerektiren kullanıcı tanımlı işlevlerin davranışıyla uyum sağlamak için
     zorlanmış kipte kullanımdan kaldırma uyarısı çıktılanmaktadır.
    </para>

    <para>
     Örneğin, <function>strlen</function> işlevinin <literal>$dizge</literal>
     bağımsız değişkeninde &string; türünde bir değer alabileceği belirtilmiş,
     &null; olabileceği belirtilmemiştir. Geriye uyumluluk adına PHP zorlayıcı
     kipte bu bağımsız değişkene değer olarak &null; aktarılmasına izin vermekte
     olup bağımsız değişken örtük olarak <type>string</type> türüne dönüştürülmekte
     ve sonuçta değer <literal>""</literal> olmaktadır. Katı kipte ise bunun
     aksine, <classname>TypeError</classname> çıktılanmaktadır.
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(strlen(null));
// "Önerilmiyor: string türündeki 1. bağımsız değişkene ($dizge) null aktarımı PHP 8.1.0 itibariyle önerilmiyor.
// int(0)

var_dump(str_contains("foobar", null));
// "Önerilmiyor: string türündeki 2. bağımsız değişkene ($iğne) null aktarımı PHP 8.1.0 itibariyle önerilmiyor.
// bool(true)
?>
]]>
     </programlisting>
    </informalexample>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>function_exists</function></member>
      <member><link linkend="funcref">İşlev Başvuru Kılavuzu</link></member>
      <member><function>get_extension_funcs</function></member>
      <member><function>dl</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonim işlevler</title>
   <simpara>
    Anonim işlevler isim belirtmeksizin oluşturulabilen işlevlerdir.
    Çoğunlukla <type>callable</type> türünde bağımsız değişkenler olarak işlev
    bağımsız değişkenlerinde kullanılırsa da kullanımı bununla sınırlı değildir.
   </simpara>
   <simpara>
    Anonim işlevler
    <link linkend="class.closure"><classname>Closure</classname></link>
    sınıfı kullanılarak gerçeklenir.
   </simpara>

    <example>
     <title>- Anonim işlev örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~',
      function ($match) {
       return strtoupper($match[1]);
      },
      'hello-world');
// Çıktısı: helloWorld
?>
]]>
     </programlisting>
    </example>
   <para>
    Anonim işlevler birer değişken değeri olarak da bildirilebilir. Bu
    durumda PHP, işlevi otomatik olarak  sınıfının nesnel bir örneği
    haline getirir. Bir anonim işlev, bir değişkene sıradan bir deyim gibi,
    bir noktalı virgül ile biten bir işlev olarak atanabilir:
   </para>
    <example>
     <title>- Değişkene anonim işlev atama örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
$greet = function($isim) {
    printf("Merhaba %s\r\n", $isim);
};

$greet('Dünya');
$greet('PHP');
?>
]]>
     </programlisting>
    </example>
   <simpara>
    Anonim işlevler değişkenleri üst etki alanından miras alabilirler. Böyle
    değişkenler <literal>use</literal> dil oluşumuna aktarılmalıdır.
    PHP 7.1 itibariyle, bu değişkenler &link.superglobals;,
    <varname>$this</varname> veya bir bağımsız değişken ile aynı isimdeki
    değişkenleri içeremez. İşlevin dönüş türü bildirimi
    <literal>use</literal> sözcüğünden <emphasis>sonra</emphasis> gelmelidir.
   </simpara>

   <example>
    <title>Değikenleri üst etki alanından miras almak</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// "use" olmaksızın
$example = function () {
    var_dump($message);
};
$example();

// $message miras alınır
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Miras alınan değişkenin değeri işlevin tanımından gelir, çağrısından değil.
$message = 'world';
$example();

// message sıfırlanır
$message = 'hello';

// Gönderimle miras alma
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Üst etki alanında değişen değer
// işlev çağrısı içinde yansıtılır.
$message = 'world';
$example();

// Anonim işlevler sıradan bağımsız değişkenleri de kabul edebilir
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");

// Dönüş türü bildirimi use sözcüğündan sonra gelir
$example = function () use ($message): string {
    return "hello $message";
};
var_dump($example());
>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
string(11) "hello world"
]]>
    </screen>
   </example>

   <para>
    Etki alanından miras alınan değişkenler listesinin sonunda bir virgül
    varsa PHP 8.0.0 itibariyle bu virgül yoksayılmaktadır.
   </para>
   <simpara>
    Üst etki alanından
    miras alınan değişkenler küresel değişkenler gibi ele alınmazlar.
    Küresel değişkenler, işlevin çalıştığı etki alanında tanımlı
    değişkenlerdir. Anonim işlevin üst etki alanı ise içinde bildirildiği
    işlevin etki alanıdır (Anonim işlevin bildirildiği etki alanı ile
    çağrıldığı etki alanı aynı olmak zorunda değildir). Aşağıdaki örneğe
    bakalım:
   </simpara>
    <example>
     <title>- Anonim işlevler ve etki alanı</title>
     <programlisting role="php">
<![CDATA[
<?php
// Ürünleri eklemek üzere bir Sepet oluşturalım.
// Eklenen ürünlerin toplam fiyatını döndürmek
// üzere bir geriçağırım işlevi kullanalım.
class Sepet
{
  const PRICE_BUTTER = 1.00;
  const PRICE_MILK = 3.00;
  const PRICE_EGGS = 6.95;

  protected $ürünler = Array();


  public static function ekle($ürün, $miktar)
  {
    $this->ürünler[$ürün] = $miktar;
  }

 public static function miktarıGetir($ürün)
 {
    return isset($this->ürünler[$ürün]) ? $this->ürünler[$ürün] : FALSE;

  }

  public function Toplam($kdv)
  {
      $toplam = 0.00;

      $işlev =
          function ($miktar, $ürün) use ($kdv, &$toplam)
          {
              $birimFiyat = constant(__CLASS__ . "::FiYAT_" .
                  strtoupper($ürün));
              $toplam += ($birimFiyat * $miktar) * ($kdv + 1.0);
          };

      array_walk($this->ürünler, $işlev);
      return round($toplam, 2);
  }
}

$sepetim = new Sepet;

// Sepete birşeyler ekleyelim
$sepetim->ekle('Peynir', 1);
$sepetim->ekle('Süt', 3);
$sepetim->ekle('Yumurta', 6);

// %5 KDV ile toplamı döndürelim
print $sepetim->Toplam(0.05) . "\n";
// sonuç: is 54.29
?>
]]>
     </programlisting>
   </example>

   <example>
    <title><literal>$this</literal>'in otomatik bağlanması</title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
   </example>

   <para>
    Bir sınıf başka bir sınıfın içinde bildirildiğinde
    <literal>$this</literal>'i işlevin etki alanı içinde kullanılabilir
    kılarak otomatik olarak ona bağlanır. Bu otomatik bağlantı
    istenmiyorsa bunun yerine
    <link linkend="functions.anonymous-functions.static">statik
    anonim işlevler</link> kullanılabilir.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Statik anonim işlevler</title>
    <para>
     Anonim işlevler statik olarak bildirilebilmektedir.
     Böylece, geçerli sınıfın otomatik olarak bunlara bağlanamaması
     sağlanabilir. Çalışma anında nesneler de otomatik olarak bunlara
     bağlanamayacaktır.
    </para>
    <para>
     <example>
      <title>- Statik anonim bir işlevin içinde <literal>$this</literal>
        kullanmaya çalışmak</title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>- Statik anonim bir işleve bir nesne bağlamaya çalışmak</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // işlev gövdesi
};

$func = $func->bindTo(new stdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Anonim işlev değişkenleri &link.superglobals;,
          <varname>$this</varname> veya bir bağımsız değişken ile aynı isimdeki
          değişkenleri içeremez.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      <function>func_num_args</function>, <function>func_get_args</function>
      ve <function>func_get_args</function> işlevini bir anonim işlev
      içinde kullanmak mümkündür.
     </simpara>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.arrow">
   <title>Ok İşlevleri</title>

   <simpara>
    Ok işlevleri PHP 7.4'te <link linkend="functions.anonymous">anonim
    işlevler</link> için daha kısa bir sözdizimi olarak tanıtılmıştır.
   </simpara>
   <simpara>
    Anonim işlevler ve ok işlevlerinin ikisi de
    <link linkend="class.closure"><classname>Closure</classname></link>
    sınıfı kullanılarak gerçeklenmiştir.
   </simpara>

   <simpara>
    Ok işlevlerinin temel biçimi:
    <code>fn (bağımsız değişkenler) =&gt; ifade</code>
   </simpara>

   <simpara>
    Ok işlevleri, üst etki alanındaki değişkenleri daima otomatik
    kullanması dışında <link linkend="functions.anonymous">anonim
    işlevler</link>in desteklediği özelliklerin tümünü destekler.
   </simpara>

   <simpara>
    İfadede kullanılan bir değişken üst etki alanında tanımlandığında,
    örtük olarak değeriyle aktarılır. Aşağıdaki örnekte
    <varname>$fn1</varname> ve <varname>$fn2</varname> işlevleri aynı
    şekilde davranır.
   </simpara>

   <para>
    <example>
     <title>- Ok işlevleri otomatik olarak değişkenleri üst etki alanından
    daima değerleriyle alır</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// $y bağımsız değişkenini değeriyle kullanmaya eşdeğerdir:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    Aşağıdaki örnek, ok işlevleri iç içe kullanılsa da çalışır:
   </simpara>
   <para>
    <example>
     <title>- Ok işlevleri otomatik olarak değişkenleri iç içe olsalar bile
       üst etki alanından daima değerleriyle alır</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// 51 çıktılanır
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Anonim işlevlere benzer olarak, ok işlevleri sözdizimi de, bağımsız değişken ve
    dönüş türleri dahil, öntanımlı değerler, değişken sayıda bağımsız değişkenler,
    gönderimli aktarım ve dönüşler gibi rasgele işlev imzalarına da izin
    verir. Aşağıdaki ok işlevlerinin tamamı geçerli örneklerdir:
   </simpara>
   <para>
    <example>
     <title>- Ok işlevi örnekleri</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn($x): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ok işlevleri değişken bağlamını değeriyle kullanır. Bu kabaca, ok işlevi
    içinde kullanılan her <varname>$x</varname> değişkeni için bir
    <code>use($x)</code> çalıştırmaya eşdeğerdir.
    Değişken bağlamını değeriyle kullanmaktan kasıt, dış etki alanındaki
    herhangi bir değerin değiştirilmesinin mümkün olmayacağıdır.
    Değişken bağlamını gönderimiyle kullanmak için
    <link linkend="functions.anonymous">anonim işlevler</link>
    kullanılabilir.
   </simpara>
   <para>
    <example>
     <title>- Dış etki alanındaki değerler ok işlevleri kullanılarak
      değiştirilemez</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // Etkisiz
$fn();
var_export($x);  // 1 çıktılanır

?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          Ok işlevleri kullanılabilir oldu.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Bir ok işlevi içinden <function>func_num_args</function>,
      <function>func_get_arg</function> ve <function>func_get_args</function>
      kullanmak mümkündür.
     </simpara>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.first_class_callable_syntax">
   <title>Birinci sınıf çağrılabilir sözdizimi</title>

   <para>
    PHP 8.1.0 itibariyle kullanılabilen birinci sınıf çağrılabilir sözdizimi
    <link linkend="language.types.callable">çağrılabilir</link>
    <link linkend="functions.anonymous">anonim işlevler</link> oluşturmanın
    bir yoludur. Dizgeleri ve dizileri kullanan mevcut çağrılabilir
    sözdiziminin yerini alır. Bu sözdiziminin getirisi statik analiz için
    erişilebilir olması ve çağrılabilirin elde edildiği etki alanın
    kullanılabilmesidir.
   </para>

   <para>
    Çağrılabilirden <classname>Closure</classname> nesne oluşturmakta
    <code>CallableExpr(...)</code> sözdizimi kullanılır.
    <code>CallableExpr</code> PHP dil yapısı içinde doğrudan çözümlenebilen
    her ifadeyi kabul eder:
    <example>
     <title>- Basit birinci sınıf çağrılabilir sözdizimi</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo {
   public function yöntem() {}
   public static function statikyöntem() {}
   public function __invoke() {}
}

$obj = new Foo();
$sınıfDizgesi = 'Foo';
$yöntemDizgesi = 'method';
$statikYöntemDizgesi = 'staticmethod';


$f1 = strlen(...);
$f2 = $obj(...);  // çağrılabilir nesne
$f3 = $obj->yöntem(...);
$f4 = $obj->$yöntemDizgesi(...);
$f5 = Foo::statikyöntem(...);
$f6 = $sınıfDizgesi::$statikYöntemDizgesi(...);

// dizi, dizge kullanan geleneksel çağrılabilir
$f7 = 'strlen'(...);
$f8 = [$obj, 'method'](...);
$f9 = [Foo::class, 'staticmethod'](...);
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
     <code>...</code> sözdiziminin bir parçası olup ihmal edilmemelidir.
    </para>
   </note>

   <para>
    <code>CallableExpr(...)</code> sözdizimi
    <methodname>Closure::fromCallable</methodname> ile aynı yapıdadır.
    Yani, dizi ve dizge kullanan çağrılabilirlerin tersine
    <code>CallableExpr(...)</code> oluşturulduğu etki alanına bağlıdır:
    <example>
     <title>- Geleneksel çağrılabilir ile <code>CallableExpr(...)</code>
      karşılaştırması</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo {
    public function getPrivateMethod() {
        return [$this, 'privateMethod'];
    }

    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}

$foo = new Foo;
$privateMethod = $foo->getPrivateMethod();
$privateMethod();
// Ölümcül hata: private yöntem Foo::privateMethod() küresel etki alanında çağrılıyor.
// Bunun nedeni, çağrının Foo dışında yapılması ve
// görünürlüğün bu noktadan denetlenmesidir.

class Foo1 {
    public function getPrivateMethod() {
        // Çağrılabilirin oluşturulduğu etki alanı kullanılıyor.
        return $this->privateMethod(...); // Closure::fromCallable([$this, 'privateMethod']); ile eşdeğer
    }

    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}

$foo1 = new Foo1;
$privateMethod = $foo1->getPrivateMethod();
$privateMethod();  // Foo1::privateMethod
?>
]]>
     </programlisting>
    </example>

   </para>

   <note>
    <para>
     Bu sözdizimini kullanarak nesne oluşturmak (<code>new Foo(...)</code>
     gibi) desteklenmemektedir. Bunun sebebi  <code>new Foo()</code>
     sözdiziminin bir işlev/yöntem çağrısı olarak ele alınmamasıdır.
    </para>
   </note>

   <note>
    <para>
     Basit birinci sınıf çağrılabilir sözdizimi ile
     <link linkend="language.oop5.basic.nullsafe">güvenli null işleci</link>
     ?-> birlikte kullanılmamalıdır. Aşağıdakilerin her biri bir derleme
     hatasıyla sonuçlanır:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj?->method(...);
$obj?->prop->method(...);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
  </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
